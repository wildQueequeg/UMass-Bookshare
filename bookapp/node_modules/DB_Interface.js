var Sequelize = require("sequelize");
var exports = module.exports = {};

/*
If you're getting an error try ensuring all the information below is correct for YOUR local DB. This will eventually be exported to an exernal file.
*/
var DB_ = "UMass-Books";
var user_ = "postgres";
var pass_ = "password";

var sequelize = new Sequelize(DB_, user_, pass_, {
    host: "localhost",
    dialect: "postgres",
    pool: {
        max: 5,
        min: 0,
        idle: 1000
    }
});

exports.getServer = sequelize;

var user_i = require("DB_user");
var book_i = require("DB_book");
var list_i = require("DB_listing");




// Legacy code that I don't want to remove just yet.
// .error(function(){
//  console.log("something went wrong");
// })

// var added;
//  added = found.spread(function(record, created)
//      {
//          console.log(created);
//          if (!created) { added = false;}
//          console.log(added + "!");
//      });
// console.log(added + " ?");       
// return added;

// }
// BookTest.sync({force: true}).then(function () { //Change sync({force: true}) to sync() to avoid dropping table on updates
//  return BookTest.create({
//      testString: "Brave New World",
//      testInt: 1932
//  });
// });


/**
 * Adds a user to the DB and passes the information to a supplied function. If the username already exists in the DB no new row will be added.
 * @param {String} username_ 
 * @param {String} password_ The unsalted + hashed password.
 * @param {Integer} age_ 
 * @param {String} firstName_
 * @param {String} lastName_
 * @param {String} sex_ m,f,o are the 3 allowed options
 * @param {String} email_
 * @param {String} phone_
 * @param {String} institution_
 * @param {String} function_ When the DB returns the result of adding a row this function is run with the result as parameters.
 */
exports.addUser = function addUser_(username_, pass_, age_, firstN_, lastN_, sex_, email_, phone_, institution_, function_) {
    user_i.addUser(username_, pass_, age_, firstN_, lastN_, sex_, email_, phone_, institution_, function_);
}
exports.addUserBasic = function addUserBasic_(username_, pass_, age_, firstN_, lastN_, sex_, email_, phone_, institution_,res_,req_) {
    user_i.addUserBasic(username_, pass_, age_, firstN_, lastN_, sex_, email_, phone_, institution_,res_,req_);
}
/**
 * Returns user information based off their username. All field, but the password, are returned in an array and passed through the supplied function.
 * @param {String} username_
 * @param {Function} function_ The result of the search will be passed as a parameter to this function. 
 * @return JSON like object of the user's values or null if not found
 */
exports.getUser = function getUser_(username_, function_) {
    user_i.getUser(username_, function_);
}
exports.checkUser = function checkUser_(username_, password_, age_, firstName_, lastName_, sex_, email_, phone_,institution_, res_,req_) {
    user_i.checkUser(username_, password_, age_, firstName_, lastName_, sex_, email_, phone_,institution_, res_,req_);
}
/**
 * Insecure method of verifying user information at the moment, a plaintext password is passed and checked against the DB's field.
 * This is not permenant but you should refactor your code so all verification can be done be an external module anyway.
 */
exports.verifyUser = function verifyUser_(username_, pass_, function_) {
    user_i.verifyUser(username_, pass_, function_);
}
exports.loginUser = function loginUser_(username_, pass_, res_,req_) {
    user_i.loginUser(username_, pass_, res_,req_);
}
/**
 * Adds a book to the DB and passes the information to a supplied function. If the isbn13 already exists in the DB no new row will be added.
 * @param {String} title_ 
 * @param {String} author_
 * @param {String} isbn10_
 * @param {String} isbn13_
 * @param {Date} publicationDate_
 * @param {Integer} version_
 * @param {Binary} cover_
 * @param {Function} function_ The result of the search will be passed as a parameter to this function. 
 * @return record[0].options.isNewRecord if you need just a boolean
 */
exports.addBook = function addBook_(title_, author_, isbn10_, isbn13_, publicationDate_, version_, cover_, function_) {
    book_i.addBook(title_, author_, isbn10_, isbn13_, publicationDate_, version_, cover_, function_);
}

/**
 * Search for results that partially match the specified fields. THIS FUNCTION IS NONFUNCTIONAL AT THE MOMENT
 * @param {String} title_ Book title to search for
 * @param {String} author_ Book author to search for
 * @param {Integer} version_ Version of the book to search for
 * @param {Function} function_ The result of the search will be passed as a parameter to this function. 
 * @return JSON like object of possible books, the results will need to be refined to get proper ordering.
 */
exports.searchBook = function searchBook_(query_, function_) {
    book_i.searchBook(query_, function_);
}

exports.searchPost = function searchPost_(query_, res_) {
    book_i.searchPost(query_, res_);
}

/** 
 * Retrieves a book from the DB based off it's ISBN13 name.
 * @param {String} isbn13_
 * @param {Function} function_ The result of the search will be passed as a parameter to this function. 
 * @return JSON like object of the book's values or null if not found
 */
exports.getBookByISBN = function getBookByISBN_(isbn_, function_) {
    if (isbn_.length == 13) {
        book_i.getBookByISBN13(isbn_, function_);
    } else if (isbn_.length == 10) {
        book_i.getBookByISBN10(isbn_, function_);
    } else {
        //TODO Throw an exception.
    }
}

/**
* Make a listing using the supplied information
* @param {String} username_
* @param {String} isbn13_
* @param {Boolean} forRent
* @param {Boolean} forSale_
* @param {Boolean} forBorrow_
* @param {Function} function_ The result of the search will be passed as a parameter to this function.
* Will error out if the username or book's isbn13 doesn't exist in the user, book tables.
*/
exports.makeListing = function makeListing_(username_, isbn13_, forRent_, rentPrice_, forSale_, sellPrice_, forBorrow_, available_, description_, function_) {
    list_i.makeListing(username_, isbn13_, forRent_, rentPrice_, forSale_, sellPrice_, forBorrow_, available_, description_, function_);
}

/**
* Find all listings a particular user has posted.
* @param {String} l istid_
* @param {Function} function_ The result of the search will be passed as a parameter to this function.
* @return JSON like object of the listing based off the listid
*/
exports.getListing = function getListing_(listid_, function_){
    list_i.getListing(listid_, function_);
}

/**
* Find all listings a particular user has posted.
* @param {String} username_
* @param {Function} function_ The result of the search will be passed as a parameter to this function.
* @return Array of JSON like object of the user's listings, iterate over to obtain each row and access column information regularly.
*/
exports.findUsersListing = function findUsersListing_(username_, function_){
    list_i.findUsersListing(username_, function_);
}

/**
* Find all listings of a particular book.
* @param {String} isbn13_
* @param {Function} function_ The result of the search will be passed as a parameter to this function.
* @return Array of JSON like object of the listings, iterate over to obtain each row and access column information regularly from them. eg. record[i].listid
*/
exports.findBookListing = function findBookListing_(isbn13_, res_){
    list_i.findBookListing(isbn13_, function_);
}
exports.postBookListing = function postBookListing_(isbn13_, res_){
    list_i.postBookListing(isbn13_, res_);
}
/**
* Make a particular listing no longer available, ie. it will not show up in further searches. If the record doesn't exist no error will be returned.
* @param {String} listid
* @param {Function} function_ This function will be called when the update completes. If you don't need it set to null.
* @return void
*/
exports.makenotAvailable = function makenotAvailable_(listid, function_){
    list_i.makenotAvailable(listid, function_);
}